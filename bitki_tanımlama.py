# -*- coding: utf-8 -*-
"""Bitki_tanımlama.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Xu_7baTO4BQ4J-Q3Vwr4NaqofkY4_CSO
"""

#burada paylaştığımız drive klasörünü yüklemeniz gerekmektedir.
#paylaştığımız klasörü kendi drive'iniza kısayol olarak eklemeniz gerekmektedir
from google.colab import drive
drive.mount('/content/drive')

!git clone https://github.com/fizyr/keras-retinanet.git

# Commented out IPython magic to ensure Python compatibility.
#gerekli kurulumları yapan blok
# %cd keras-retinanet/
!pip install .
!python setup.py build_ext --inplace

#kütüphaneler
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
import requests
import urllib
import os
from PIL import Image
import cv2

from keras_retinanet import models
from keras_retinanet.utils.image import preprocess_image, resize_image
from keras_retinanet.utils.visualization import draw_box, draw_caption
from keras_retinanet.utils.colors import label_color

import xml.etree.ElementTree as ET

#labelimg sayesinde sağladığımız xml dosyalarından dataframe oluşumu sağlanır.
df_train = pd.DataFrame()
i=0
for filename in os.listdir('/content/drive/My Drive/bitki tanıma proje/train_20/'):
    if filename.split('.')[1] == 'xml':
      i+=1
      print(i)
      converted_data_train = {
      'image_name': [],
      'x_min': [],
      'y_min': [],
      'x_max': [],
      'y_max': [],
      'class_name': [],}
      tree = ET.parse("/content/drive/My Drive/bitki tanıma proje/train_20/" +filename)
      root = tree.getroot()
      imname = root.find('filename').text
      converted_data_train['image_name'] ="/content/drive/My Drive/bitki tanıma proje/train_20/" + imname

      for boxes in root.iter('object'):
          ymin, xmin, ymax, xmax = None, None, None, None
          objname = boxes.find("name").text
          converted_data_train['class_name'] = objname
          for box in boxes.findall("bndbox"):
              ymin = int(box.find("ymin").text)
              xmin = int(box.find("xmin").text)
              ymax = int(box.find("ymax").text)
              xmax = int(box.find("xmax").text)
              converted_data_train['x_min'] = int(xmin)
              converted_data_train['y_min'] = int(ymin)
              converted_data_train['x_max'] = int(xmax)
              converted_data_train['y_max'] = int(ymax)
          df_train = df_train.append(converted_data_train, ignore_index=True)

#labellanmış bir fotoğrafın örneğini gösterir.
def show_image_with_boxes(df):
  filepath = df.sample()['image_name'].values[0]


  df2 = df[df['image_name'] == filepath]
  im = np.array(Image.open(filepath))

  im = im[:,:,:3]

  for idx, row in df2.iterrows():
    box = [
      row['x_min'],
      row['y_min'],
      row['x_max'],
      row['y_max'],
    ]
    print(box)
    draw_box(im, box, color=(0, 255, 0))

  plt.axis('off')
  plt.imshow(im)
  plt.show()

#dataframein içeriği
df_train

df_train = df_train[['image_name', 'x_min', 'y_min', 'x_max', 'y_max', 'class_name']]

#gerekli argümanlar stringden inte dönüştürülür.
df_train = df_train.astype({"x_min": int, "y_min": int, "x_max": int, "y_max": int})

show_image_with_boxes(df_train)

#annotations.csv oluşturulur.
df_train.to_csv('annotations.csv', index=False, header=None)

#classnameler gösterilir.
df_train.class_name.unique()

#classes.csv oluşturulur
classes = ['demir dikeni zehirli', 'gelincik zehirli',
       'guzelavrat otu zehirli', 'hazeran zehirli', 'kanarya otu zehirli',
       'kanavci otu zehirli', 'karamuk zehirli', 'porsuk otu zehirli',
       'yabani salgam zehirli', 'yuksuk otu zehirli',
       'sari tas yoncasi zehirsiz', 'sorgum zehirsiz',
       'soya fasulyesi zehirsiz', 'tarla sarmasigi zehirsiz',
       'yonca zehirsiz', 'burcak zehirsiz', 'cilek ucgulu zehirsiz',
       'hayvan pancari zehirsiz', 'kirmizi ucgul zehirsiz',
       'korunga zehirsiz']
with open('classes.csv', 'w') as f:
  for i, class_name in enumerate(classes):
    f.write(f'{class_name},{i}\n')

!head classes.csv

!head annotations.csv

#bu adımda colaba snapshots dosya dizinini oluşturur. train yapılacaksa gereklidir
import os
if not os.path.exists('snapshots'):
  os.mkdir('snapshots')

#resnet50 in başlangıç ağırlıklarını yükler.
PRETRAINED_MODEL = 'snapshots/_pretrained_model.h5'

URL_MODEL = 'https://github.com/fizyr/keras-retinanet/releases/download/0.5.1/resnet50_coco_best_v2.1.0.h5'
urllib.request.urlretrieve(URL_MODEL, PRETRAINED_MODEL)

print('Downloaded pretrained model to ' + PRETRAINED_MODEL)

# Commented out IPython magic to ensure Python compatibility.
#modellerin bulunduğu konuma gidiyoruz.
# %cd /content/drive/MyDrive/"bitki tanıma proje"/model_bitki/
#%cd keras-retinanet/

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard

#eğitim aşaması
!keras_retinanet/bin/train.py  --random-transform \
  --weights {PRETRAINED_MODEL} \
  --batch-size 1 \
  --steps 569 \
  --epochs 80 \
  csv annotations.csv classes.csv

# Commented out IPython magic to ensure Python compatibility.

# %tensorboard --logdir snapshots/

#drivedaki modellerimizi görüntülüyoruz en başarılı bulduğumuz iki modeli drive a kaydettik.
!ls /content/drive/MyDrive/"bitki tanıma proje"/model_bitki/
#!ls snapshots

#modelimizi bu adımda yüklüyoruz.
model = models.load_model("resnet50_csv_44.h5", backbone_name='resnet50')
#model = models.load_model("./snapshots/resnet50_csv_44.h5", backbone_name='resnet50')
model = models.convert_model(model)

label_map = {}
for line in open('classes.csv'):
  row = line.rstrip().split(',')
  label_map[int(row[1])] = row[0]

#modelden resim tahmininin yapıldığı kod kısmı çıktısında resim üzerinde thresholdun üstünde bi başarısı varsa yazdırır. konsol kısmında ise test edebilmek
#tahmin ettiği tüm değerler yazdırılmıştır.
def show_image_with_predictions(df, threshold=0.6):

  row = df.sample()
  filepath = row['image_name'].values[0]
  print("filepath:", filepath)

  df2 = df[df['image_name'] == filepath]
  im = np.array(Image.open(filepath))
  print("im.shape:", im.shape)
  im = im[:,:,:3]
  for idx, row in df2.iterrows():
    box = [
      row['x_min'],
      row['y_min'],
      row['x_max'],
      row['y_max'],
    ]
    print(box)
    draw_box(im, box, color=(255, 0, 0))
  imp = preprocess_image(im)
  imp, scale = resize_image(im)
  boxes, scores, labels = model.predict_on_batch(
    np.expand_dims(imp, axis=0)
  )
  boxes /= scale
  for box, score, label in zip(boxes[0], scores[0], labels[0]):
    print(score,label_map[label])
    if score < threshold:
      break
    box = box.astype(np.int32)
    color = label_color(label)
    draw_box(im, box, color=color)
    class_name = label_map[label]
    caption = f"{class_name} {score:.3f}"
    font = cv2.FONT_HERSHEY_SIMPLEX 
    fontScale = 1
    color = (255, 0, 0) 
    thickness = 1 
    org = (box[0]-25,box[1]-25)
    im = cv2.putText(im, caption, org, font,  fontScale, color, thickness, cv2.LINE_AA) 
    #draw_caption(im, box, caption)

  plt.axis('off')
  plt.imshow(im)
  plt.show()

#colabdaki resimin size ayarı
plt.rcParams['figure.figsize'] = [20, 10]

print(label_map)

#denemeler
show_image_with_predictions(df_train, threshold=0.5)

show_image_with_predictions(df_train, threshold=0.5)

show_image_with_predictions(df_train, threshold=0.6)

show_image_with_predictions(df_train, threshold=0.4)

show_image_with_predictions(df_train, threshold=0.5)

show_image_with_predictions(df_train, threshold=0.5)

show_image_with_predictions(df_train, threshold=0.6)

show_image_with_predictions(df_train, threshold=0.6)

show_image_with_predictions(df_train, threshold=0.6)

show_image_with_predictions(df_train, threshold=0.6)

show_image_with_predictions(df_train, threshold=0.6)

show_image_with_predictions(df_train, threshold=0.6)